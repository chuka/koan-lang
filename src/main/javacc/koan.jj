/*
 *  koan.jj
 *
 *  JavaCC specification for Koan.
 */

options {
  UNICODE_INPUT = true;
  STATIC = false;
}

PARSER_BEGIN(Parser)

package edu.lmu.cs.xlg.koan.syntax;

import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import edu.lmu.cs.xlg.util.Log;
import edu.lmu.cs.xlg.koan.entities.*;


public class Parser {
    /**
     * Returns the result of parsing the Koan program on the given Reader.
     */
    public Script parse(Reader reader, Log log) {
        try {
            return parseScript();
        } catch (TokenMgrError e) {
            log.exception(e);
            return null;
        } catch (ParseException e) {
            log.exception(e);
            return null;
        }
    }
}

PARSER_END(Parser)

SKIP: { 
    < (" " | "\t" | "\r" | "\n")+ > 
    | <"c:" (~["\n","\r"])*>
}

TOKEN: {
    "(" | ")" | "[" | "]" | "{" | "}" | "-" | "+" | "/" | "*" | "**" | ":="
    | "&&" | "||" | "==" | "<=" | ">=" | "!=" | "," | ".." | "..." | "f:"
    | "8:" | "->"  | "T" | "F"   
    
    | <NUMTYPE: "#">
    | <STRTYPE: "$">
    | <BOOLTYPE: "^">
    | <FUNTYPE: "f">
    | <REGEXTYPE: "@">
    | <NULLTYPE: "~">
    
    | <INTLIT: (["0"-"9"])+> 
    | <STRING: (["A"-"Z", "a"-"z", "0"-"9"])+ >
    | <CHARLIT: (["A"-"Z", "a"-"z"])>
    | <BR: ";">
    | <ID: ["A"-"Z" , "a"-"z" , "0"-"9"] (["-" , "_" , "A"-"Z" , "a"-"z" , "0"-"9"])+ >
}

Script SCRIPT(): {} { ( STMT() <BR> )+ }
Statement STMT(): {} {
    LOOKAHEAD(6)
      DEC()
    | LOOKAHEAD({getToken(2).image == ":="})ASSIGNMENT()
    | PRINTSTMT()
    | IFSTMT()
    | LOOP()
    | EXP()
}

Statement DEC(): {} { 
    LOOKAHEAD(2)
      VARDEC() 
    | CONSTDEC() 
    }
Variable VARDEC(): {} { TYPE() <ID> ":=" EXP() }
Variable CONSTDEC(): {} { TYPE() <ID> "!" ":=" EXP() }
Type TYPE(): {} { 
    <NUMTYPE> 
    | <STRTYPE> 
    | <BOOLTYPE> 
    | <FUNTYPE> 
    | <REGEXTYPE>
    | <NULLTYPE> 
}
Type RETURNTYPE(): {} { TYPE() }
Parameters PARAMS(): {} { ( <ID> ( "," <ID> )* )* }

Statement ASSIGNMENT(): {} {
     LOOKAHEAD(2) 
       ( <ID> ":=" EXP() ) 
     | SWAP() }
Statement SWAP(): {} {  <ID> ":=:" <ID>  }
Statement PRINTSTMT(): {} { "p:" EXP() }
Statement IFSTMT(): {} {
    "??:" EXP() "?" STMT() 
    ( LOOKAHEAD({getToken(3).image == "?"}) 
    ":" EXP() "?" STMT() )*
    (LOOKAHEAD({getToken(2).kind == Statement})
     ":" STMT() )? 
}

Statement LOOP(): {} { 
    LOOKAHEAD(2)
      FORLOOP() 
    | INFINITELOOP() 
    }
Statement FORLOOP(): {} { "8:" RANGE() ( ANONFUN() | ( <ID> BLOCK() ) ) }
Statement INFINITELOOP(): {} { "8:" BLOCK() }
Statement PROCCALL(): {} { ( ( <ID> "(" ARGS() ")" ) | ANONFUN() ) }
Block BLOCK(): {} { "{" (STMT() <BR>)* "}" }

Boolean BOOL(): {} { "T" | "F" }
Expression EXP():  {} { EXP1() ( "||" EXP1() )* }
Expression EXP1(): {} { EXP2() ( "&&" EXP2() )* }
Expression EXP2(): {} { EXP3() ( RELOP() EXP3() )? }
Expression EXP3(): {} { EXP4() ( EXPNOP() EXP4() )? }
Expression EXP4(): {} { EXP5() ( LOOKAHEAD({getToken(2).image == ("*" | "/" | "%")})MULOP() EXP4() )* }
Expression EXP5(): {} { EXP6() ( LOOKAHEAD({getToken(2).image == ("+" | "-" )}) ADDOP() EXP5() )* }
Expression EXP6(): {} {
      LIT() 
    | ARRAY() 
    | LOOKAHEAD({getToken(2).image == "{"}) OBJECT()
    | LOOKAHEAD({getToken(2).image == "("}) PROCCALL() 
    | LOOKAHEAD({getToken(2).image == "["}) ARRAYREF() 
    | <ID>
}

String RELOP():  {} { "<" | "<=" | "==" | "!=" | ">=" | ">" }
String EXPNOP(): {} { "**" }
String MULOP():  {} { "*" | "/" | "%"}
String ADDOP():  {} { "+" | "-" }

Literal LIT(): {} { 
   LOOKAHEAD(3)
   BOOL() 
   | <INTLIT> 
   | <STRING> 
   | <CHARLIT>
}
Array ARRAY(): {} { "[" ( EXP() )* ( "," EXP() )* "]" }
void ARRAYREF(): {} { <ID> "[" ( LOOKAHEAD(2) EXP() | RANGE() ) "]" }
Object OBJECT(): {} { <ID> "{" ( <ID> ":" EXP() "," )+ "}" }
Function ANONFUN(): {} { "f:" ( PARAMS() "->" )? BLOCK() }

RegularExpression REGEX(): {} { <ID> ":=" "/" <STRING> "/" }

void ARGS(): {} { EXP5() ( "," EXP5() )* }
Range RANGE(): {} {
      ( "..." | ".." ) EXP()
    | EXP() ( "..." | ".." ) (LOOKAHEAD({getToken(3).kind == Expression}) EXP())?
}

void S(): {} { E() <EOF>                                   }
void E(): {} { LOOKAHEAD(2) <ID> ":=" E() | T() ( "+" T() )* }
void T(): {} { F() ( "*" F() )*                              }
void F(): {} { <INTLIT> | <STRING> | <CHARLIT> | <BR> | "(" E() ")"                  }
