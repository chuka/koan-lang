/*
 *  koan.jj
 *
 *  JavaCC specification for Koan.
 */
//DG - One option to solve parser errs is to change each String t that has a getType returned to it is to make them Types
//instead of Strings
options {
  UNICODE_INPUT = true;
  STATIC = false;
}

PARSER_BEGIN(Parser)

package edu.lmu.cs.xlg.koan.syntax;

import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import edu.lmu.cs.xlg.util.Log;
import edu.lmu.cs.xlg.koan.entities.*;


public class Parser {
    /**
     * Returns the result of parsing the Koan program on the given Reader.
     */
    public Script parse(Reader reader, Log log) {
        try {
            return parseScript();
        } catch (TokenMgrError e) {
            log.exception(e);
            return null;
        } catch (ParseException e) {
            log.exception(e);
            return null;
        }
    }
}

PARSER_END(Parser)

SKIP: {
    < (" " | "\t" | "\r" | "\n")+ >
    | <"c:" (~["\n","\r"])*>
}

TOKEN: {
    "(" | ")" | "[" | "]" | "{" | "}" | "-" | "+" | "/" | "*" | "**" | ":="
    | "&&" | "||" | "==" | "<=" | ">=" | "!=" | "," | ".." | "..." | "f:"
    | "8:" | "->"  | "T" | "F"

    | <NUMTYPE: "#">
    | <STRTYPE: "$">
    | <BOOLTYPE: "^">
    | <FUNTYPE: "f">
    | <REGEXTYPE: "@">
    | <NULLTYPE: "~">

    | <INTLIT: (["0"-"9"])+>
    | <STRING: (["A"-"Z", "a"-"z", "0"-"9"])+ >
    | <CHARLIT: (["A"-"Z", "a"-"z"])>
    | <BR: ";">
    | <EMPTYLINE: "\\n">
    | <ID: ["A"-"Z" , "a"-"z" , "0"-"9"] (["-" , "_" , "A"-"Z" , "a"-"z" , "0"-"9"])+ >
}

Script parseScript(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
} {
    (<EMPTYLINE>)*
    (s = parseStmt() {statements.add(s);})+
    (<EMPTYLINE>)*
    <EOF>
    {return new Script(statements);}
}

Statement parseStmt(): {
    Statement s;
} {
    (
         LOOKAHEAD(parseDec())
        s = parseDec()
        |LOOKAHEAD({getToken(2).image == ":="})
        s = parseAssignment()
        | s = parsePrintStmt()
        | s = parseIfStmt()
        | s = parseLoopStmt()
        //Expression is not a statement, though derived as such in EBNF
        //maybe use the simplestmnt as roflkode does... hierarchy matter
        | s = parseExp()
    )
    (<BR>)
    (LOOKAHEAD(<EMPTYLINE>)<EMPTYLINE>)*
    {return s;}
}

Statement parseDec(): {
    Statement s;
} {
    (
        LOOKAHEAD(2)
          s = parseVarDec()
        | s = parseConstDec()
        //| s = parseObjectDec()
    )
    {return s;}
}

Variable parseVarDec(): {
    String t = null;
    Token v = null;
    Expression e = null;
    boolean constant = false;
} {
    (LOOKAHEAD (parseType() <ID>) t = parseType())?
    v = <ID>
    (":=" e = parseExp())?
    {return new Variable(v.image, t.toString(), e, constant);}
}

Variable parseConstDec(): {
    String t = null;
    Token v = null;
    Expression e = null;
    boolean constant = true;
} {

    (LOOKAHEAD (parseType() <ID> "!") t = parseType())?
    v = <ID>
    (":=" e = parseExp())?
    {return new Variable(v.image, t, e, constant);}
}

/*
ObjectType parseObjectDec(): {
    String t;
    Token objectTypeName;
    Token key;
    Expression value;
    List<ObjectType.Property> properties = new ArrayList<ObjectType.Property>();
} {
    (LOOKAHEAD ({parseType() == "o"}) t = parseType())?
    objectTypeName = <ID> "{"
    (
       key = <ID> ":" value = parseExp() ","
       {properties.add(new ObjectType.Property(key.image, value));}
       (<BR>)*
    )*
    (
       key = <ID> ":" value = parseExp()
       {properties.add(new ObjectType.Property(key.image, value));}
       (<BR>)*
    )+
    { return new ObjectType(objectTypeName.image, properties); }
}
*/

VariableReference parseVarRef(): {
    Token t;
} {
    t = <ID>
    {return new VariableReference(t.image);}
}



String parseType(): {
    Token i;
    StringBuilder builder = new StringBuilder();
} {
    (   i = <NUMTYPE>
        | i = <STRTYPE>
        | i = <BOOLTYPE>
        | i = <FUNTYPE>
        | i = <REGEXTYPE>
        | i = <NULLTYPE>
    )
    {builder.append(i.image);}
    (
        LOOKAHEAD(2) parseArrayExp() {builder.append(" ARRAY");}
    )*
    {return builder.toString();}
}


Statement parseAssignment(): {
    Statement s = null;
    VariableReference v = null;
    Expression e = null;
} {
    (
        LOOKAHEAD(2)
          ( parseVarRef() ":=" parseExp() )
          v = parseVarRef()
          ":="
          e = parseExp()
          { s = new AssignmentStatement(v, e); }
        | s = parseSwap()
    )
    {return s;}
}


Statement parseSwap(): {
    VariableReference v1 = null;
    VariableReference v2 = null;
} {
    (
        v1 = parseVarRef()
        ":=:"
        v2 = parseVarRef()
    )
    {return new SwapStatement(v1, v2);}
}


Statement parsePrintStmt(): {
    Expression e = null;
} {
    ("p:" e = parseExp())
    {return new PrintStatement(e);}
}



Statement parseIfStmt(): {
    IfStatement.Arm arm;
    List<IfStatement.Arm> arms = new ArrayList<IfStatement.Arm>();
    Expression e;
    Block b;
    Block elseBlock = null;
} {
    (
        "??:" e = parseExp() "?" b = parseBlock()
        { arms.add(new IfStatement.Arm(e,b)); }
        (
            LOOKAHEAD({ getToken(3).image == "?" })
            ":" e = parseExp() "?" elseBlock = parseBlock()
            { arms.add(new IfStatement.Arm(e, elseBlock)); }
        )*
        (
            LOOKAHEAD({ getToken(2).image == ":" })
            ":" elseBlock = parseBlock()
            { arms.add(new IfStatement.Arm(null, elseBlock)); }
        )?
    )
}

Statement parseLoopStmt(): {
    Statement s;
} {
    (
      LOOKAHEAD(2)
        s = parseForLoop()
      | s = parseInfiniteLoop()
    )
    { return s; }
}

Statement parseForLoop(): {
    Expression iterationExpression = null;
    Expression executeFunction = null;
    Block executeBlock = null;
    Token blockParam = null;
} {
    (
        "8:"
        iterationExpression = parseExp()
        /*
        (
            iterationValues = parseRange()
            | iterationValues = parseArrayExp()
            | iterationValues = parseVarRef()
        )*/
        (
            LOOKAHEAD(parseExp())
            executeFunction = parseExp()
            | (
                blockParam = <ID>
                executeBlock = parseBlock()
            )
        )
    )
    { return new ForLoop(iterationExpression, executeFunction, executeBlock, blockParam.image); }
}

Statement parseInfiniteLoop(): {
    Block executeBlock;
} {
    ("8:" executeBlock = parseBlock())
    { return new InfiniteLoop(executeBlock); }
}

Block parseBlock(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
} {
    "{" ( s = parseStmt() {statements.add(s);} )* "}"
    { return new Block(statements); }
}

Expression parseExp(): {
    Expression e1;
    Expression e2;
} {
    e1 = parseExp1()
    ("||" e2 = parseExp2() {e1 = new BinaryExpression(e1, "||", e2);})*
    { return e1; }
}

Expression parseExp1(): {
    Expression e1;
    Expression e2;
} {
    e1 = parseExp2()
    ( "&&" e2 = parseExp2() {e1 = new BinaryExpression(e1, "&&", e2);} )*
    { return e1; }
}

Expression parseExp2(): {
    String op;
    Expression e1;
    Expression e2;
} {
    e1 = parseExp3()
    (
        op = parseRelOp()
        e2 = parseExp3()
        { e1 = new BinaryExpression(e1, op, e2); }
    )?
    { return e1; }
}

Expression parseExp3(): {
    String op;
    Expression e1;
    Expression e2;
} {
    e1 = parseExp4()
    (
        op = parseExpnOp()
        e2 = parseExp4()
        { e1 = new BinaryExpression(e1, op, e2); }
    )?
    { return e1; }
}

Expression parseExp4(): {
    String op;
    Expression e1;
    Expression e2;
} {
    e1 = parseExp5()
    (
        LOOKAHEAD({
            getToken(2).image == "*"
            | getToken(2).image == "/"
            | getToken(2).image == "%"
        })
        op = parseMulOp()
        e2 = parseExp4()
        { e1 = new BinaryExpression(e1, op, e2); }
    )*
    { return e1; }
}

Expression parseExp5(): {
    String op;
    Expression e1;
    Expression e2;
} {
    e1 = parseExp6()
    (
        LOOKAHEAD({
            getToken(2).image == "+"
            | getToken(2).image == "-"
        })
        op = parseAddOp()
        e2 = parseExp5()
        { e1 = new BinaryExpression(e1, op, e2); }
    )*
    { return e1; }
}

Expression parseExp6(): {
    String op;
    Expression e1;
    Expression e2;
} {
    e1 = parseExp7()
    (
        LOOKAHEAD({
            getToken(2).image == ".."
            | getToken(2).image == "..."
        })
        op = parseRangeOp()
        e2 = parseExp6()
        { e1 = new BinaryExpression(e1, op, e2); }
    )*
    { return e1; }
}

Expression parseExp7(): {
    Expression e;
    Token t;
} {
    (
      e = parseLiteral()
   /*   | (
          LOOKAHEAD({getToken(2).image == "{"})
          e = parseObject()
        )
    */
      | (
          LOOKAHEAD({getToken(2).image == "("})
          e = parseFunCall()
        )
      | (
          LOOKAHEAD({getToken(2).image == "["})
          e = parseArrayExp()
        )
      | e = parseVarRef()
    )
    { return e; }
}



String parseRelOp():  {
    Token s;
} {
    s = "<" | s = "<=" | s = "==" | s = "!=" | s = ">=" | s = ">"
    { return s.image; }
}

String parseExpnOp(): {
    Token s;
} {
    s = "**"
    { return s.image; }
}

String parseMulOp():  {
    Token s;
} {
    s = "*" | s = "/" | s = "%"
    { return s.image; }
}

String parseAddOp():  {
    Token s;
} {
    s = "+" | s = "-"
    { return s.image; }
}

String parseRangeOp():  {
    Token s;
} {
    s = ".." | s = "..."
    { return s.image; }
}

Literal parseLiteral(): {} {
   (LOOKAHEAD(3) parseBool()
   | <INTLIT>
   | <STRING>
   | <CHARLIT>)
   {return new Literal("Not done yet");}
}

Entity parseBool(): {} { "T" | "F" }

ArrayExpression parseArrayExp(): {
    Expression e = null;
    List<Expression> list = new ArrayList<Expression>();
} {
    "["
      e = parseExp() {list.add(e);}
      (LOOKAHEAD(2)","e = parseExp() {list.add(e);} )*
    "]"
    {return new ArrayExpression(list);}
}

Entity parseFunCall(): {
    Token t;
    List<Expression> list = new ArrayList<Expression>();
    Block body = new ArrayList<Expression>();
} {
    (
        LOOKAHEAD({getToken(5) == "->"})
        (<ID> "(" list = parseArgs() ")" "->" "{" body = parseBlock()"}" )         
        |( <ID>  "(" list = parseArgs() ")")
        | parseAnonFun()
    )
    { return new Function(list, body); }
}

Function parseAnonFun(): {
    List<Variable> params = new ArrayList<Variable>();
    Block body = null;
} {
    (
        "f:"
        ("(" parseParams(params) ")" "->")?
        body = parseBlock()
    )
    {return new Function(params, body);}
}

void parseParams(List<Variable> params): {
    Token p;
} {
    (
        p = <ID>
        {params.add(new Variable(p.image, "INFERENCED", null, false));}
        (
            "," p = <ID>
            {params.add(new Variable(p.image, "INFERENCED", null, false));}
        )*
    )
}

/*
Entity parseRegex(): {} {
    <ID> ":=" "/" <STRING> "/"
    { return new Entity(); }
}
*/

List parseArgs(): {
    List<Expression> expressions = new ArrayList<Expression>();
    Expression e = null;
} {
    e = parseExp5() { expressions.add(e); }
    ( "," parseExp5() { expressions.add(e); })*
    { return expressions; }
}

/*
Range parseRange(): {
    Expression lowerBound = null;
    Expression upperBound = null;
} {
      ( "..." | ".." ) upperBound = parseExp()
    | lowerBound = parseExp() ( "..." | ".." )
      (LOOKAHEAD({getToken(3).kind == Expression}) upperBound = parseExp())?
    { return new Range(lowerBound, upperBound); }
}
*/
void S(): {} { E() <EOF>                                   }
void E(): {} { LOOKAHEAD(2) <ID> ":=" E() | T() ( "+" T() )* }
void T(): {} { F() ( "*" F() )*                              }
void F(): {} { <INTLIT> | <STRING> | <CHARLIT> | <BR> | "(" E() ")"                  }
